{"ts":1371822827612,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * socket.io-node\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar parser = require('./parser')\n  , util = require('./util')\n  , EventEmitter = process.EventEmitter\n\n/**\n * Export the constructor.\n */\n\nexports = module.exports = Socket;\n\n/**\n * Default error event listener to prevent uncaught exceptions.\n */\n\nvar defaultError = function () {};\n\n/**\n * Socket constructor.\n *\n * @param {Manager} manager instance\n * @param {String} session id\n * @param {Namespace} namespace the socket belongs to\n * @param {Boolean} whether the \n * @api public\n */\n\nfunction Socket (manager, id, nsp, readable) {\n  this.id = id;\n  this.namespace = nsp;\n  this.manager = manager;\n  this.disconnected = false;\n  this.ackPackets = 0;\n  this.acks = {};\n  this.setFlags();\n  this.readable = readable;\n  this.store = this.manager.store.client(this.id);\n  this.on('error', defaultError);\n};\n\n/**\n * Inherits from EventEmitter.\n */\n\nSocket.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Accessor shortcut for the handshake data\n *\n * @api private\n */\n\nSocket.prototype.__defineGetter__('handshake', function () {\n  return this.manager.handshaken[this.id];\n});\n\n/**\n * Accessor shortcut for the transport type\n *\n * @api private\n */\n\nSocket.prototype.__defineGetter__('transport', function () {\n  return this.manager.transports[this.id].name;\n});\n\n/**\n * Accessor shortcut for the logger.\n *\n * @api private\n */\n\nSocket.prototype.__defineGetter__('log', function () {\n  return this.manager.log;\n});\n\n/**\n * JSON message flag.\n *\n * @api public\n */\n\nSocket.prototype.__defineGetter__('json', function () {\n  this.flags.json = true;\n  return this;\n});\n\n/**\n * Volatile message flag.\n *\n * @api public\n */\n\nSocket.prototype.__defineGetter__('volatile', function () {\n  this.flags.volatile = true;\n  return this;\n});\n\n/**\n * Broadcast message flag.\n *\n * @api public\n */\n\nSocket.prototype.__defineGetter__('broadcast', function () {\n  this.flags.broadcast = true;\n  return this;\n});\n\n/**\n * Overrides the room to broadcast messages to (flag)\n *\n * @api public\n */\n\nSocket.prototype.to = Socket.prototype.in = function (room) {\n  this.flags.room = room;\n  return this;\n};\n\n/**\n * Resets flags\n *\n * @api private\n */\n\nSocket.prototype.setFlags = function () {\n  this.flags = {\n      endpoint: this.namespace.name\n    , room: ''\n  };\n  return this;\n};\n\n/**\n * Triggered on disconnect\n *\n * @api private\n */\n\nSocket.prototype.onDisconnect = function (reason) {\n  if (!this.disconnected) {\n    this.$emit('disconnect', reason);\n    this.disconnected = true;\n  }\n};\n\n/**\n * Joins a user to a room.\n *\n * @api public\n */\n\nSocket.prototype.join = function (name, fn) {\n  var nsp = this.namespace.name\n    , name = (nsp + '/') + name;\n\n  this.manager.onJoin(this.id, name);\n  this.manager.store.publish('join', this.id, name);\n\n  if (fn) {\n    this.log.warn('Client#join callback is deprecated');\n    fn();\n  }\n\n  return this;\n};\n\n/**\n * Un-joins a user from a room.\n *\n * @api public\n */\n\nSocket.prototype.leave = function (name, fn) {\n  var nsp = this.namespace.name\n    , name = (nsp + '/') + name;\n\n  this.manager.onLeave(this.id, name);\n  this.manager.store.publish('leave', this.id, name);\n\n  if (fn) {\n    this.log.warn('Client#leave callback is deprecated');\n    fn();\n  }\n\n  return this;\n};\n\n/**\n * Transmits a packet.\n *\n * @api private\n */\n\nSocket.prototype.packet = function (packet) {\n  if (this.flags.broadcast) {\n    this.log.debug('broadcasting packet');\n    this.namespace.in(this.flags.room).except(this.id).packet(packet);\n  } else {\n    packet.endpoint = this.flags.endpoint;\n    packet = parser.encodePacket(packet);\n\n    this.dispatch(packet, this.flags.volatile);\n  }\n\n  this.setFlags();\n\n  return this;\n};\n\n/**\n * Dispatches a packet\n *\n * @api private\n */\n\nSocket.prototype.dispatch = function (packet, volatile) {\n  if (this.manager.transports[this.id] && this.manager.transports[this.id].open) {\n    this.manager.transports[this.id].onDispatch(packet, volatile);\n  } else {\n    if (!volatile) {\n      this.manager.onClientDispatch(this.id, packet, volatile);\n    }\n\n    this.manager.store.publish('dispatch:' + this.id, packet, volatile);\n  }\n};\n\n/**\n * Stores data for the client.\n *\n * @api public\n */\n\nSocket.prototype.set = function (key, value, fn) {\n  this.store.set(key, value, fn);\n  return this;\n};\n\n/**\n * Retrieves data for the client\n *\n * @api public\n */\n\nSocket.prototype.get = function (key, fn) {\n  this.store.get(key, fn);\n  return this;\n};\n\n/**\n * Checks data for the client\n *\n * @api public\n */\n\nSocket.prototype.has = function (key, fn) {\n  this.store.has(key, fn);\n  return this;\n};\n\n/**\n * Deletes data for the client\n *\n * @api public\n */\n\nSocket.prototype.del = function (key, fn) {\n  this.store.del(key, fn);\n  return this;\n};\n\n/**\n * Kicks client\n *\n * @api public\n */\n\nSocket.prototype.disconnect = function () {\n  if (!this.disconnected) {\n    this.log.info('booting client');\n\n    if ('' === this.namespace.name) {\n      if (this.manager.transports[this.id] && this.manager.transports[this.id].open) {\n        this.manager.transports[this.id].onForcedDisconnect();\n      } else {\n        this.manager.onClientDisconnect(this.id);\n        this.manager.store.publish('disconnect:' + this.id);\n      }\n    } else {\n      this.packet({type: 'disconnect'});\n      this.manager.onLeave(this.id, this.namespace.name);\n      this.$emit('disconnect', 'booted');\n    }\n\n  }\n\n  return this;\n};\n\n/**\n * Send a message.\n *\n * @api public\n */\n\nSocket.prototype.send = function (data, fn) {\n  var packet = {\n      type: this.flags.json ? 'json' : 'message'\n    , data: data\n  };\n\n  if (fn) {\n    packet.id = ++this.ackPackets;\n    packet.ack = true;\n    this.acks[packet.id] = fn;\n  }\n\n  return this.packet(packet);\n};\n\n/**\n * Original emit function.\n *\n * @api private\n */\n\nSocket.prototype.$emit = EventEmitter.prototype.emit;\n\n/**\n * Emit override for custom events.\n *\n * @api public\n */\n\nSocket.prototype.emit = function (ev) {\n  if (ev == 'newListener') {\n    return this.$emit.apply(this, arguments);\n  }\n\n  var args = util.toArray(arguments).slice(1)\n    , lastArg = args[args.length - 1]\n    , packet = {\n          type: 'event'\n        , name: ev\n      };\n\n  if ('function' == typeof lastArg) {\n    packet.id = ++this.ackPackets;\n    packet.ack = lastArg.length ? 'data' : true;\n    this.acks[packet.id] = lastArg;\n    args = args.slice(0, args.length - 1);\n  }\n\n  packet.args = args;\n\n  return this.packet(packet);\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":6508}]],"length":6508}
